# -*- mode: sh; eval: (sh-set-shell "bash") -*-

# the logics a changing
function svn_exists() {
	[ -z "$1" ] && echo "";
	local d="$AMI_SVND";
	local pkg="$1";
	local ret="";
	for r in $SVN_REPOS; do
		[ -d "$d/$r/$pkg/.svn" ] && {
			ret+="$r";
		}
	done
	echo "$ret";
}
# because get != update

# svn_log repo pkg
function svn_log() {
	[ -z $SVN_SERVER ] && die 128 "svn_log() SVN_SERVER not set";
	local srv=$SVN_SERVER
	[ -z $1 ] && echo "# svn_log() defaulting to 'packages' repo" >&2;
	local repo=${1:-packages}
	[ -z $2 ] && echo "# svn_log() defaulting to 'pacman' pkg" >&2;
	local pkg=${2:-pacman}
	# not to HOT a name as far as demangling it back goes...
	local tofile="$pkg-$repo-log"
	# echo svn log svn://$srv/$repo $pkg >&2
	[ -f "$tofile" ] &&
	  echo "# svn_log() $tofile already present" >&2 ||
	  svn log svn://$srv/$repo $pkg > "$tofile";
# svn return 0 too even on fail?...
	[ $? -eq 0 ] && echo "$tofile" || { rm -f "$tofile"; echo ""; }
}

### TODO: investigate this damn scope and why we had to move it to
### collect() when . sourcing... MEH

# (0:rev 1:author 2:date 3:msglinenum 4:msgline1 5:msgline2 ... N-1:msgbytes N:rev ...)
declare -a rdata=()
declare -i didx=0
declare -a index=()
declare -i iidx=0
# no can doop... subshelling in while ruins everything (BLEH[tm])

# cat $(svn_log repo pkg) | svn_proc_log | svn_collect_log with_fun_name args
function svn_proc_log() {
	local -i in=0
	local -i msgchars=0
	while read ; do
		# omit starting *dashed* line delim
		[ $in -eq 0 ] && echo "$REPLY" | grep -q -- "^-\+$" && continue
		# check for rev heading; process if so...
		echo "$REPLY" | grep -q '^r[[:digit:]]* |.*' && {
			in=1;
			echo "$REPLY" | sed 's/ | /\n/g';
			continue;
		}
		# skip first blank in msg...
		[ $in -eq 1 ] && echo "$REPLY" | grep -q "^$" && {
			in=2;
			continue;
		}
		# treat log msg...
		[ $in -eq 2 ] && echo "$REPLY" | grep -q -- "^-\+$" || {
			# echo "PASSING: \"$REPLY\"" >&2
			echo "$REPLY";
			msgchars+=$(echo "$REPLY" | wc -c)
			continue;
		}
		# not counting "Last Feed"
		echo "commit_msg_byte_length     "$([ $msgchars -gt 0 ] && echo $(($msgchars-1)) || echo 0);
		msgchars=0;
		# else restart search
		## echo "($in)restarting $iidx $didx ${#index[*]} ${#rdata[*]}" >&2
		in=0;
		# irrelavent
		## iidx+=1;
	done
}
### SLOW AS HELL ###
function svn_collect_log() {
	declare -a rdata=()
	declare -i didx=0
	declare -a index=()
	declare -i iidx=0
	while read; do
		### echo -n "collect: " >&2;
		echo "$REPLY" | grep -q '^r[[:digit:]]*$' && {
			rdata[${didx}]=$(echo "$REPLY" | sed 's/^r//g');
			index[${iidx}]=${didx};
			iidx+=1;
			} || {
			echo "$REPLY" | grep -q '^[[:digit:]]* line.*$' && {
				rdata[${didx}]=$(echo "$REPLY" | sed 's/ line.*//g');
				}
			} || {
			# LOL
			echo "$REPLY" | grep -q '^commit_msg_byte_length     [[:digit:]]*$' && {
				rdata[${didx}]=$(echo "$REPLY" | sed 's/^commit_msg_byte_length     //g');
				}
			} || {
			rdata[${didx}]="$REPLY";
			} # || { ... perhaps ignore more ...
		### echo $iidx $didx >&2;
	didx=$(($didx+1));	
	### echo "\"${index[$(($iidx-1))]}\" \"${rdata[$(($didx-4))]}\" \"${rdata[$(($didx-3))]}\" \"${rdata[$(($didx-2))]}\" \"${rdata[$(($didx-1))]}\"" >&2;
	done
# fuck
	$@
}

## recreating log back (for testing)...
# separatour
function prnrevsep() {
	# damn slow, butt
	local -i len=72
	local -i i=0
	while [ $i -lt $len ]; do
		echo -n "-";
		i+=1;
	done
	echo
}
# print one rev byte for byte...
function prntrev() {
	[ -z $1 ] && return
	local -i rev=$1
	local -i len=${#index[*]}
	local -i start=${index[$rev]}
	rev+=1
	local -i end
	[ $rev -eq $len -o $rev -eq 0 ] && {
		end=${#rdata[*]} ; } ||
	end=${index[$rev]}

	end=$(($end-1))
	if [ $start -lt $end ]; then
		echo -n "r";
	local -i eek=0
	while [ $start -lt $end ]; do
		case $eek in
			0|1|2)
				echo -n "${rdata[$start]} | " ;;
			3)
				[ "${rdata[$start]}" = "1" ] &&
				echo "${rdata[$start]} line" ||
				echo "${rdata[$start]} lines" ;
				echo ;;
			*)
				echo "${rdata[$start]}" ;;
		esac
		eek+=1;
		start+=1;
	done
	prnrevsep
	fi
}
# print all revs
function prnallrevs() {
	local -i i=0
	local -i l=${#index[*]}
	[ $l -gt 0 ] && prnrevsep
	while [ $i -lt $l ]; do
		prntrev $i;
		i+=1;
	done
}
# print all revs reversed order
function prnallrevsrevs() {
	local -i l=${#index[*]}
	local -i i=$(($l-1))
	[ $l -gt 0 ] && prnrevsep
	while [ $i -ge 0 ]; do
		prntrev $i;
		i=$(($i-1));
	done
}
# print recent/or/first N (minus is from the start or r1)
function prnsomerevs() {
	local -i l=${#index[*]}
	local -i N=${1:-5}
	[ $N -gt 0 -a $N -gt $l ] && N=$l
	[ $N -eq 0 ] && N=$l
	[ $N -lt 0 -a $N -lt -$l ] && N=-$l
# no nie wiem...
	local s=$([ $N -gt 0 ] && seq 0 1 $(($N-1)) || seq -1 -1 $N)
	prnrevsep
	for i in $s; do
		# echo "N=$i"
		prntrev $i;
	done
}

### "fast" importing or at least a start ova

# svn_export_rev repo pkg rev
function svn_export_rev() {
	[ -z $SVN_SERVER ] && die 128 "svn_export_rev() SVN_SERVER not set";
	local srv=$SVN_SERVER
	[ -z $1 ] && echo "# svn_export_rev() defaulting to 'packages' repo" >&2;
	local repo=${1:-packages}
	[ -z $2 ] && echo "# svn_export_rev() defaulting to 'pacman' pkg" >&2;
	local pkg=${2:-pacman}
	[ -z $3 ] && echo "# svn_export_rev() defaulting to SVN r1" >&2;
	local rev=${3:-1}
	local todir="$pkg/$repo/r$rev"
	[ -d "$todir" ] &&
	  echo "# svn_export_rev() $todir already present" >&2 ||
	  svn export -r$rev svn://$srv/$repo/$pkg "$todir" 1>&2;
	# yeah... we should do it like this, except THAT
	[ $? -eq 0 ] && echo "$todir" >&2 || echo "" >&2;
}

function writing-fi-files() {
	local -i mark=$1
	local pkg=$2
	local idx=${index[$3]}
	local rev=${rdata[$idx]}
	local -i linezoff=${rdata[$(($idx+3))]}
	local -i msgbytes=${rdata[$(($idx+4+$linezoff))]}
	local file=$4
	local afile=$file-admin
	local bfile=$file-blobs
	local repo=$5
	local FILES
	local expdir
	local commie

	{
		echo "progress Creating rev $rev";
		# this is oh so temporary... variabilize it?
		echo "commit refs/heads/p/${pkg}/arch";
		echo "mark :$mark";
		commit=$mark;
		mark+=1;
		commie=${rdata[$(($idx+1))]}
		echo "committer $commie <$commie AT svn> ${rdata[$(($idx+2))]}";
		echo "data $msgbytes";
		# print logmsg
		local -i i=1
		while [ $i -le $linezoff ]; do
			echo "${rdata[$(($idx+3+$i))]}";
			i+=1;
		done
		echo "deleteall";
		# here goes the filelist and BLOBing...
		expdir=$pkg/$repo/r$rev
		FILES=($(find "$expdir" -type f))
		# echo "M 644 :$mark FILEZ";
		for f in ${FILES[@]}; do
			{
				echo "progress Importing $f";
				echo "blob";
				echo "mark :$mark";

				echo "data "$(stat -c %s "$f");
				cat "$f";
			} >> $bfile
			# boolbool
			echo "M "$(stat -c %a "$f")" :$mark "$(echo "$f" | sed "s,/r$rev/,/,g;s,/$repo/,/,g;s,/repos/,/,g;s,/trunk/,/$repo/,g");
			mark+=1;
		done
		echo
	 } > $afile
	cat $bfile $afile >> $file
	rm -f $bfile $afile
	echo "$commit $mark"
}

# going down...
function fast-import() {
	local repo=$1
	local pkg=$2
	local bfile="$pkg/fast-imps"
	# local bfile="$pkg/fast-imps-$repo"?
	# but than caller will only known of the LAST one... TOFIX
	local -i l=${#index[*]}
	local -i i=$(($l-1))
	local -i mark=1
	local -i revi
	local -i revision=0
	commit=0
	# delete if already present
	rm -f "$bfile";
	while [ $i -ge 0 ]; do
		revi=${index[$i]};
		revision=${rdata[$revi]};
		svn_export_rev $repo $pkg $revision;
		ret=$(writing-fi-files $mark $pkg $i "$bfile" $repo);
		# silly...
		commit=$(echo $ret | sed 's/ .*$//g');
		mark=$(echo $ret | sed 's/^[^ ]* //g');
		i=$(($i-1));
	done
	[ $revision -gt 0 ] && {
		# oh, what shall Ay call dee?
		tagname="$pkg-$repo-r$revision"
		echo "progress Creating tag '$tagname'";
		# hmmm...
		echo "tag $tagname";
		echo "from :$commit";
		echo "tagger ami.sh <$USER AT $HOSTNAME> "$(date);
		echo "data 0";
	} >> "$bfile"
	# this is sooo, very sick...
	echo "$bfile";
}

# cat log_file | proc | collect fast-import community tix fi-file
