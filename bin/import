#!/bin/bash

load etc ami
#settings
load lib ami # runcmd...
load lib $(basename $0)
load lib svn
load lib aur

#dbgargs "$@"

function import_aur() {
	echo "via AUR";
	echo "# AUR import being implemented, mostly 'aur get'ing it...";
	local b="p/$pkg/aur";
	# be careful what we ask for (grep args in 'status git $pkg' may collide...
	runcmd status git $pkg | grep -q "$b" && die 234 "# $b already present";
	# or -v or -all switch in status git...
	runcmd aur get $pkg;
	# always try to get teh latest...
	local vers=($(aur_exists $pkg));
	[ ${#vers[*]} -gt 0 ] || die 235 "# import_aur() nothing to do";
	echo -e "# available versions (in modification)sic!(time order)\n";
	for v in ${vers[@]}; do
		[[ "$v" =~ .*/"$pkg-"([^/]*)".tar.gz" ]] && echo "${BASH_REMATCH[1]}";
	done
	#echo -e "\n###\n"; #or
	#echo ${vers[@]} | sed 's/\(\.tar\.gz\) /\1\n/g' | sed 's/.*\/'$pkg'-\(.*\)\.tar\.gz/\1/g';
	echo;
	# prolly insert "good order?" prompt here...
	local tout=300
	read -p "Press SPACE to continue. " -N 1 -s -t $tout ||
	  die $? "TIMEOUT after $tout seconds.";
	[ "$REPLY" = " " ] || die $? "Bye, then.";
	echo "Okidoki.";

	cd $AMI_TEMP/imports/aur/ || die 1 "# cd temp import failure";
	rm -f $pkg-fast-import;
	aur_fast_import $pkg ${vers[@]} > $pkg-fast-import;
	# NOW
	[ $? -eq 0 ] && {
		echo "# Importing GIT fast-import file for pkg($pkg) of repo(aur)";
		# cd $AMI_GITD && cat "$impdir/$fi_file" | git fast-import --quiet --date-format=rfc2822;
		export GIT_DIR="$AMI_GITD/.git"; cat "$pkg-fast-import" | git fast-import --quiet --date-format=rfc2822; } || {
		echo "# KABLOOM!";
	}

	# clean-up?
	# rm -f $pkg-fast-import;
}
# NOT nice $pkg global...
function import_svn() {
	echo "via Arch Linux SVN"
	echo "SVN import ALMOST really implemented, kabloom!"
	local b="p/$pkg/arch"
	runcmd status git $pkg | grep -q "$b" && die 234 "# $b already present"
	local repos=($(svn_exists $pkg))
	# perhaps svn_get here too? hmmm...
	[ "${#repos[*]}" -eq 0 ] && {
		runcmd svn get $pkg
	}
	repos=($(svn_exists $pkg))
	[ "${#repos[*]}" -eq 0 ] && die 235 "# it appears there is no $pkg package in Arch (${repos[@]})"
	# TODO?: find (if it exists) and import all of history besides present "location"
	[ "${#repos[*]}" -gt 1 ] && die 236 "# $pkg exists in both repos (IM-possible!)"
	# trash da place
	local impdir=$AMI_TEMP/imports/svn/$pkg
	mkdir -p $impdir && cd $impdir || die 1 "# cd $impdir failure"
	local fi_file="fast-import"
	rm -f $fi_file
	local log_file
	for r in ${repos[@]}; do
		log_file=$(svn_log $r $pkg)
		[ -z "$log_file" ] && continue
		echo "# (re-)generating GIT fast-import file for pkg($pkg) of repo($r)";
		cat $log_file | svn_collect_log_to fast-import $r $pkg $fi_file
	done
	# echo "# Importing into GIT" >&2;
	[ ! -s "$fi_file" ] && {
		echo "# empty $fi_file (impossible, but TRUE)";
		rm -f "$fi_file";
	} || {
		cd $AMI_GITD && cat "$impdir/$fi_file" | git fast-import --quiet --date-format=rfc2822;
		# && rm -f "$fi_file";
		# leaving for now, but it's expandable as long as we leave svn_log and
		# svn_export_rev files behind during 'svn import'
	}
	# clean up... but leave svn_export cache for sure, no point in redownloading
	# and they pack good.
	# rm -f $impdir/$fi_file;
}

function import() {
	echo -n "# importing $pkg "
	case $1 in
		aur)
			import_aur ;;
		svn)
			import_svn ;;
		*)
			import_aur ;;
	esac
}

function import_usage() {
	echo "# '$AMI_PROG import <pkg> aur' is default"
	echo "Usage: $AMI_PROG import <pkg> [svn|aur]"
}

# main()
case $1 in
	-h)
			import_usage ;;
	*)
			pkg=$1
			shift
			[ -z "$pkg" ] &&
			  import_usage ||
			  import $* ;;
esac
